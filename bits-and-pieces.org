* Unary postfix
Редуцированный язык с двумя литералами и одним постфиксным оператором.

#+begin_src prog
expr ::= 0 | 1 | expr!
#+end_src

#+name: unpost
#+begin_src emacs-lisp :lexical t :var input="0!!!"
(require 'cl-lib)

(cl-flet ((code ()
            (cl-ecase (char-after)
              (?0 0)
              (?1 1)
              (?! '(aref [1 0] left))))
          (run (code)
            (eval code))
          (advance ()
            (forward-char)))
  (with-temp-buffer
    (insert input)
    (goto-char (point-min))
    (dlet (left)
      (while (not (eobp))
        ;; q0
        (setq left (run (code)))
        (advance))
      left)))
#+end_src

#+RESULTS: unpost
: 1

#+RESULTS:
: 1

* Unary prefix
Редуцированный язык с двумя литералами и одним префиксным оператором.

#+begin_src prog
expr ::= 0 | 1 | !expr
#+end_src

#+begin_src emacs-lisp :lexical t :var input="!!!1"
(require 'cl-lib)

(let ((env (obarray-make)) left)
  (cl-flet ((code ()
              (cl-assert (looking-at "[01!]"))
              (symbol-value (obarray-get env (match-string 0))))
            (run (code)
              (funcall code left))
            (advance ()
              (goto-char (match-end 0))))
    (set (obarray-put env "0") (lambda (_left) 0))
    (set (obarray-put env "1") (lambda (_left) 1))
    (set (obarray-put env "!")
         (lambda (_left)
           (let ((c (code)))
             (advance)
             (aref [1 0] (run c)))))
    (with-temp-buffer
      (insert input)
      (goto-char (point-min))
      (while (not (eobp))
        ;; q0
        (let ((c (code)))
          (advance)
          (setq left (run c))))
      left)))
#+end_src

#+RESULTS:
: 0

* Infix
Язык с двумя инфиксными операторами разных приоритетов и двумя литералами.

#+begin_src prog
expr ::= disj
disj ::= conj | disj "|" disj
conj ::= prim | conj & conj
prim ::= 0 | 1
#+end_src

#+begin_src emacs-lisp :lexical t :var input="0&1|0&1"
(require 'cl-lib)

(let ((env (obarray-make)))
  (cl-flet*
      ((nud ()
         (cl-assert (looking-at "[01|&]"))
         (let ((token (match-string 0)))
           (or (get (obarray-get env token) 'nud)
               (lambda ()
                 (error "No null denotation: `%s'" token)))))

       (led (left)
         (cl-assert (looking-at "[01|&]"))
         (let* ((token (match-string 0))
                (led (get (obarray-get env token) 'led)))
           (if led
               (lambda ()
                 (funcall led left))
             (lambda ()
               (error "No left denotation: `%s'" token)))))

       (lbp ()
         (or (and (looking-at "[01|&]")
                  (get (obarray-get env (match-string 0)) 'lbp))
             0))

       (advance ()
         (goto-char (match-end 0)))

       (run (code)
         (funcall code))

       (parse (rbp)
         ;; q0
         (let ((c (nud)))
           (advance)
           (let ((left (run c)))
             ;; q1
             (while (< rbp (lbp))
               (setq c (led left))
               (advance)
               (setq left (run c)))
             left))))

    (put (obarray-put env "0") 'nud (lambda () 0))
    (put (obarray-put env "1") 'nud (lambda () 1))

    (put (obarray-put env "|") 'lbp 1)
    (put (obarray-put env "|") 'led
         (lambda (left)
           (aref [0 1 1 1] (+ (* 2 left) (parse 1)))))

    (put (obarray-put env "&") 'lbp 2)
    (put (obarray-put env "&") 'led
         (lambda (left)
           (aref [0 0 0 1] (+ (* 2 left) (parse 2)))))

    (with-temp-buffer
      (insert input)
      (goto-char (point-min))
      (let (left)
        (while (not (eobp))
          (setq left (parse 0)))
        left))))
#+end_src

#+RESULTS:
: 0

* Arith
Что-то вроде арифметики целых положительных чисел.

#+begin_src prog
expr ::= sum
sum ::= mul | sum + mul
mul ::= pow | mul * pow
pow ::= lit | pow ^ lit
lit ::= [0-1]+
#+end_src

#+begin_src emacs-lisp :lexical t :var input="4^3+2*1"
(require 'cl-lib)

(let ((env (obarray-make)))
  (cl-flet*
      ((nud ()
         (cl-assert (looking-at "\\([0-9]+\\)\\|[+*^]"))
         (let ((token (match-string 0)))
           (cond
            ((get (obarray-get env token) 'nud))
            ((match-string 1)
             (lambda ()
               (string-to-number token)))
            (t
             (lambda ()
               (error "No null denotation: `%s'" token))))))

       (led (left)
         (cl-assert (looking-at "\\([0-9]+\\)\\|[+*^]"))
         (let* ((token (match-string 0))
                (led (get (obarray-get env token) 'led)))
           (if led
               (lambda ()
                 (funcall led left))
             (lambda ()
               (error "No left denotation: `%s'" token)))))

       (lbp ()
         (or (and (looking-at "\\([0-9]+\\)\\|[+*^]")
                  (get (obarray-get env (match-string 0)) 'lbp))
             0))

       (advance ()
         (goto-char (match-end 0)))

       (run (code)
         (funcall code))

       (parse (rbp)
         ;; q0
         (let ((c (nud)))
           (advance)
           (let ((left (run c)))
             ;; q1
             (while (< rbp (lbp))
               (setq c (led left))
               (advance)
               (setq left (run c)))
             left))))

    (put (obarray-put env "+") 'lbp 1)
    (put (obarray-put env "+") 'led (lambda (left) (+ left (parse 1))))

    (put (obarray-put env "*") 'lbp 2)
    (put (obarray-put env "*") 'led (lambda (left) (* left (parse 2))))

    (put (obarray-put env "^") 'lbp 3)
    (put (obarray-put env "^") 'led (lambda (left) (expt left (parse 3))))

    (with-temp-buffer
      (insert input)
      (goto-char (point-min))
      (let (left)
        (while (not (eobp))
          (setq left (parse 0)))
        left))))
#+end_src

#+RESULTS:
: 66

* nud and led
Язык с двузначными токенами.

#+begin_src emacs-lisp :lexical t
(require 'cl-lib)

(let ((env (obarray-make))
      (token-pattern "\\([0-9]+\\)\\|[+-]"))
  (cl-flet*
      ((nud ()
         (cl-assert (looking-at token-pattern))
         (let ((token (match-string 0)))
           (cond
            ((get (obarray-get env token) 'nud))
            ((match-string 1)
             (lambda ()
               (string-to-number token)))
            (t
             (lambda ()
               (error "No null denotation: `%s'" token))))))

       (led (left)
         (cl-assert (looking-at token-pattern))
         (let* ((token (match-string 0))
                (led (get (obarray-get env token) 'led)))
           (cond
            (led
             (lambda ()
               (funcall led left)))
            (t
             (lambda ()
               (error "No left denotation: `%s'" token))))))

       (lbp ()
         (or (and (looking-at token-pattern)
                  (get (obarray-get env (match-string 0)) 'lbp))
             0))

       (advance ()
         (goto-char (match-end 0)))

       (run (code)
         (funcall code))

       (parse (rbp)
         ;; q0
         (let ((c (nud)))
           (advance)
           (let ((left (run c)))
             ;; q1
             (while (< rbp (lbp))
               (setq c (led left))
               (advance)
               (setq left (run c)))
             left))))

    (dolist (op '(+ -))
      (let ((symbol (obarray-put env (symbol-name op))))
        (put symbol 'nud (lambda () (funcall op (parse 0))))
        (put symbol 'led (lambda (left) (funcall op left (parse 1))))
        (put symbol 'lbp 1)))

    (with-temp-buffer
      (insert "--1+++1--1")
      (goto-char (point-min))
      ;; (pop-to-buffer (current-buffer))
      (let (left)
        (while (not (eobp))
          (setq left (parse 0)))
        left))))
#+end_src

* Prover
Прувер, частично на Елиспе.

#+begin_src emacs-lisp :lexical t :var input="(a→b)∧(b→c)→(a→c)?"
(require 'cl-lib)

(let ((env (obarray-make))
      (token-pattern "[()?~→∧∨]\\|[a-z]+")
      (k 1))

  (cl-flet*
      ;; denotation accessors
      ((set-nud (name value)
         (set (obarray-put env name) value))

       (get-nud (name)
         (symbol-value (obarray-get env name)))

       (set-led (name binding-power function)
         (fset (obarray-put env name) (cons binding-power function)))

       (get-led (name)
         (cdr (symbol-function (obarray-get env name))))

       (get-lbp (name)
         (car (symbol-function (obarray-get env name))))

       ;; prover primitives
       (generate ()
         (prog1
             (vconcat (make-vector k 0)
                      (make-vector k 1))
           (cl-callf ash k 1)))

       (isvalid (x)
         (not (seq-some #'zerop x)))

       (boole (m x y &optional op)
         (let* ((lx (length x))
                (ly (length y))
                (result (make-vector (max lx ly) 0)))
           (dotimes (i (length result))
             (let ((cx (aref x (% i lx)))
                   (cy (aref y (% i ly))))
               (aset result i (aref m (logxor #b11 (ash cx 1) cy)))))
           (message "boole(%s, %s, %s) = %s" (or op m) x y result)
           result))

       ;; language/parser primitives
       (nud ()
         (cl-assert (looking-at token-pattern))
         (let ((self (match-string 0)))
           (or (get-nud self)
               (funcall (get-led "nonud") self))))

       (led (left)
         (cl-assert (looking-at token-pattern))
         (let ((led (or (get-led (match-string 0))
                        (get-led "noled"))))
           (lambda ()
             (funcall led left))))

       (lbp ()
         (if (eobp)
             0
           (cl-assert (looking-at token-pattern))
           (or (get-lbp (match-string 0)) 0)))

       (advance ()
         (goto-char (match-end 0)))

       (run (code)
         (funcall code))

       (parse (rbp)
         ;; q0
         (let ((c (nud)))
           (advance)
           (let ((left (run c)))
             ;; q1
             (while (< rbp (lbp))
               (setq c (led left))
               (advance)
               (setq left (run c)))
             left)))

       ;; helpers
       (check (token)
         (if (looking-at (regexp-quote token))
             (advance)
           (error "Missing `%s'" token))))

    (set-led "nonud" nil
             (lambda (self)
               (cl-check-type self string)
               (if (null (get-led self))
                   (let ((truth-table (generate)))
                     (set-nud self (lambda () truth-table)))
                 (error "`%s' has no argument" self))))

    (set-led "?" 1
             (lambda (left)
               (if (isvalid left)
                   (message "Theorem")
                 (message "Non-theorem"))
               ;; (parse 1)
               ))

    (set-nud "\(" (lambda () (prog1 (parse 0) (check "\)"))))
    (set-led "\)" 0 nil)
    ;; Ошибка, мы используем перевернутые таблицы истинности (не
    ;; обратные, хотя для импликации эти понятия совпадают).
    ;; (set-led "→" 2 (lambda (left) (boole [1 1 0 1] left (parse 1) "→")))
    (set-led "→" 2 (lambda (left) (boole [1 0 1 1] left (parse 1) "→")))
    (set-led "∨" 3 (lambda (left) (boole [1 1 1 0] left (parse 3) "∨")))
    (set-led "∧" 4 (lambda (left) (boole [1 0 0 0] left (parse 4) "∧")))
    ;; Вторая ошибка, отрицание можно реализовать как сравнение с 0,
    ;; но таблица истинности для эквивалентности 1001, а не 0101.
    ;; Выражение для проверки: a∧~a→b
    (set-nud "~" (lambda () (boole [1 0 0 1] (parse 5) [0] "~")))

    (with-temp-buffer
      ;; (pop-to-buffer (current-buffer))
      (insert "a∧~a→b→c→d→foo?")
      (goto-char (point-min))
      (let (left)
        (while (not (eobp))
          (setq left (parse 0)))
        left))))
#+end_src

#+RESULTS:
: Theorem
